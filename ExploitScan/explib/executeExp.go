package explib

import (
	"fmt"
	"github.com/google/cel-go/common/types/ref"
	"github.com/nerowander/MultiCheck/PocScan/poclib"
	"github.com/nerowander/MultiCheck/common"
	"github.com/nerowander/MultiCheck/config"
	"net/http"
	"strings"
	"sync"
)

type Task struct {
	Req *http.Request
	Exp *poclib.Poc
}

func CheckMultiExp(req *http.Request, exps []*poclib.Poc, workers int) {
	tasks := make(chan Task)
	var wg sync.WaitGroup
	for i := 0; i < workers; i++ {
		go func() {
			for task := range tasks {
				isVul, _, name := executeExp(task.Req, task.Exp)
				if isVul {
					result := fmt.Sprintf("[+] ExpScan %s %s %s", task.Req.URL, task.Exp.Name, name)
					common.LogSuccess(result)
				}
				wg.Done()
			}
		}()
	}
	for _, exp := range exps {
		task := Task{
			Req: req,
			Exp: exp,
		}
		wg.Add(1)
		tasks <- task
	}
	wg.Wait()
	close(tasks)
}

func executeExp(oReq *http.Request, p *poclib.Poc) (bool, error, string) {
	var successCount int
	successCount = 0
	//c := poclib.NewEnvOption()
	// 可以将这个c设为全局变量，然后让这个exp模块直接引用poc之前定义下来的即可

	// 单执行exp的时候需要一次更新
	if config.ScanType == "exploit" || config.NoPOC == true {
		poclib.C.UpdateCompileOptions(p.Set)
		if len(p.Sets) > 0 {
			var setMap poclib.StrMap
			for _, item := range p.Sets {
				if len(item.Value) > 0 {
					setMap = append(setMap, poclib.StrItem{Key: item.Key, Value: item.Value[0]})
				} else {
					setMap = append(setMap, poclib.StrItem{Key: item.Key})
				}
			}
			poclib.C.UpdateCompileOptions(setMap)
		}
	}
	env, err := poclib.NewEnv(&poclib.C)
	if err != nil {
		fmt.Printf("[-] %s environment creation error: %s\n", p.Name, err)
		return false, err, ""
	}
	var req *poclib.Request
	req, err = poclib.ParseRequest(oReq)
	if err != nil {
		fmt.Printf("[-] %s ParseRequest error: %s\n", p.Name, err)
		return false, err, ""
	}

	variableMap := make(map[string]interface{})
	defer func() { variableMap = nil }()
	variableMap["request"] = req

	for _, item := range p.Set {
		k, expression := item.Key, item.Value
		// for example
		// set:
		// reverse: newReverse()
		// reverseURL: reverse.url
		if expression == "newReverse()" {
			// dnslog反连
			if !config.DnsLog {
				return false, nil, ""
			}
			variableMap[k] = poclib.NewReverse()
			continue
		}
		err, _ = poclib.EvalSet(env, variableMap, k, expression)
		if err != nil {
			fmt.Printf("[-] %s evalset error: %v\n", p.Name, err)
		}
	}

	success := false
	//爆破模式，比如弱口令爆破，敏感目录扫描等
	if len(p.Sets) > 0 {
		//success, err = poclib.BrutePoc(oReq, p, variableMap, req, env)
		success, err = bruteExp(oReq, p, variableMap, req, env)
		return success, nil, ""
	}

	//非爆破模式
	DealWithRule := func(name string, rule poclib.Rules) (bool, error) {
		Headers := poclib.MapClone(rule.Headers)
		var (
			flag, ok bool
		)
		for k1, v1 := range variableMap {
			_, isMap := v1.(map[string]string)
			if isMap {
				continue
			}
			value := fmt.Sprintf("%v", v1)
			for k2, v2 := range Headers {
				if !strings.Contains(v2, "{{"+k1+"}}") {
					continue
				}
				Headers[k2] = strings.ReplaceAll(v2, "{{"+k1+"}}", value)
			}
			// 针对于web base的情况替换path和body
			// 目前支持替换path和body、expression
			// 考虑checkwebshellpath的检查
			if strings.HasPrefix(name, "base") {
				rule.Path = strings.ReplaceAll(rule.Path, "{{"+"path"+"}}", config.RequestPath)
				rule.Path = strings.ReplaceAll(rule.Path, "{{"+"checkwebshellpath"+"}}", config.CheckWebshellPath)
				rule.Body = strings.ReplaceAll(rule.Body, "{{"+"body"+"}}", config.RequestBody)
				rule.Body = strings.ReplaceAll(rule.Body, "{{"+"writewebshellbody"+"}}", config.WriteWebShellBody)
				rule.Body = strings.ReplaceAll(rule.Body, "{{"+"pocbody"+"}}", config.PocBody)
				rule.Body = strings.ReplaceAll(rule.Body, "{{"+"webshellcommand"+"}}", config.WebShellCommand)
				rule.Expression = strings.ReplaceAll(rule.Expression, "{{"+"checkpocres"+"}}", config.CheckPocResBody)
				rule.Expression = strings.ReplaceAll(rule.Expression, "{{"+"checkexpres"+"}}", config.CheckExpResBody)
				rule.Expression = strings.ReplaceAll(rule.Expression, "{{"+"checkwebshellcmdres"+"}}", config.CheckWebShellCmdBody)
			} else {
				rule.Path = strings.ReplaceAll(rule.Path, "{{"+k1+"}}", value)
				rule.Body = strings.ReplaceAll(rule.Body, "{{"+k1+"}}", value)
			}
		}

		if oReq.URL.Path != "" && oReq.URL.Path != "/" {
			req.Url.Path = fmt.Sprint(oReq.URL.Path, rule.Path)
		} else {
			req.Url.Path = rule.Path
		}
		req.Url.Path = strings.ReplaceAll(req.Url.Path, " ", "%20")

		var newRequest *http.Request
		newRequest, err = http.NewRequest(rule.Method, fmt.Sprintf("%s://%s%s", req.Url.Scheme, req.Url.Host, req.Url.Path), strings.NewReader(rule.Body))
		if err != nil {
			//fmt.Println("[-] newRequest error: ",err)
			return false, err
		}
		newRequest.Header = oReq.Header.Clone()
		for k, v := range Headers {
			newRequest.Header.Set(k, v)
		}
		Headers = nil
		var resp *poclib.Response
		resp, err = poclib.DoRequest(newRequest, rule.FollowRedirects)
		newRequest = nil
		if err != nil {
			return false, err
		}
		variableMap["response"] = resp

		if rule.Search != "" {
			result := poclib.ResSearch(rule.Search, poclib.FormatHeader(resp.Headers)+string(resp.Body))
			if len(result) > 0 { // 正则匹配成功
				for k, v := range result {
					variableMap[k] = v
				}
			} else {
				return false, nil
			}
		}
		var out ref.Val
		out, err = poclib.Evaluate(env, rule.Expression, variableMap)
		if err != nil {
			return false, err
		}
		//如果false不继续执行后续rule
		// 如果最后一步执行失败，就算前面成功了最终依旧是失败
		flag, ok = out.Value().(bool)
		if !ok {
			flag = false
		}
		return flag, nil
	}

	DealWithRules := func(name string, rules []poclib.Rules) bool {
		successFlag := false
		for _, rule := range rules {
			var flag bool
			flag, err = DealWithRule(name, rule)
			if err != nil || !flag { //如果false不继续执行后续rule
				successFlag = false // 如果其中一步为false，则直接break
				break
			}
			//successCount +=1 // 统计成功次数
			successFlag = true
		}
		return successFlag
	}

	if len(p.Rules) > 0 {
		success = DealWithRules(p.Name, p.Rules)
		if success {
			successCount += 1
		}
	} else {
		// groups是分组的rules
		for _, item := range p.Groups {
			//name, rules := item.Key, item.Value
			_, rules := item.Key, item.Value
			// 要全部执行成功才算成功
			success = DealWithRules(p.Name, rules)
			if success {
				//return success, nil, name
				successCount += 1
			}
		}
	}
	if successCount >= len(p.Rules)+len(p.Groups) {
		success = true
	} else {
		success = false
	}
	return success, nil, ""
}
