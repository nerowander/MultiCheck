package Modules

import (
	"ExploitScan/WebScan/rules"
	"ExploitScan/common"
	"ExploitScan/config"
	"ExploitScan/explib"
	"ExploitScan/poclib"
	"embed"
	"fmt"
	"gopkg.in/yaml.v2"
	"io/fs"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"sync"
)

var (
	once sync.Once
	//go:embed exps
	Exploits embed.FS
	// 因为 explib.Exp 和 poclib.Poc 的结构体定义相同，所以使用同一个变量
	AllExps []*poclib.Poc
)

func WebExploit(info *config.InfoScan) {
	once.Do(initExp)
	var expInfo = config.ExpInfo
	buf := strings.Split(info.Url, "/")
	expInfo.Target = strings.Join(buf[:3], "/")
	// 和webPocScan是类似的

	if config.ExpType == "base" {
		if config.ExpName == "" {
			executeExp(expInfo)
		} else {
			expInfo.ExpName = config.ExpName
			executeExp(expInfo)
		}
	} else if config.ExpType == "software" {
		for _, infoStr := range info.WebInfo {
			expInfo.ExpName = checkInfoExp(infoStr)
			executeExp(expInfo)
		}
	} else if config.ExpType == "iot" {
		// todo：补充iot模块
		// 应该是和web base是类似的
		if config.ExpName == "" {
			executeExp(expInfo)
		} else {
			expInfo.ExpName = config.ExpName
			executeExp(expInfo)
		}
	} else if config.ExpType == "all" {
		// web+iot
		if config.ExpName == "" {
			// web base and iot
			executeExp(expInfo)
			for _, infoStr := range info.WebInfo {
				// web software
				expInfo.ExpName = checkInfoExp(infoStr)
				executeExp(expInfo)
			}
		} else {
			// web base and iot
			expInfo.ExpName = config.ExpName
			executeExp(expInfo)
			for _, infoStr := range info.WebInfo {
				// web software
				expInfo.ExpName = checkInfoExp(infoStr)
				executeExp(expInfo)
			}
		}
	} else {
		fmt.Println("[-] invalid ExpType: " + config.ExpType)
		return
	}
}

func initExp() {
	// 内置exp
	var entries []fs.DirEntry
	var err error
	if config.ExpPath == "" {
		if config.ExpType == "base" {
			entries, err = Exploits.ReadDir("exps/base")
		} else if config.ExpType == "software" {
			entries, err = Exploits.ReadDir("exps/software")
		} else if config.ExpType == "iot" {
			entries, err = Exploits.ReadDir("exps/iot")
		} else if config.ExpType == "all" {
			entries, err = Exploits.ReadDir("exps/all")
		} else {
			fmt.Println("[-] invalid ExpType: " + config.ExpType)
			return
		}
		if err != nil {
			fmt.Printf("[-] init exp error: %v", err)
			return
		}
		for _, one := range entries {
			path := one.Name()
			// 解析yaml或yml
			if strings.HasSuffix(path, ".yaml") || strings.HasSuffix(path, ".yml") {
				if exp, _ := loadExp(path, Exploits); exp != nil {
					AllExps = append(AllExps, exp)
				}
			}
		}
	} else {
		// 自定义exp
		fmt.Println("[+] load exp from " + config.ExpPath)
		err = filepath.Walk(config.ExpPath,
			func(path string, info os.FileInfo, err error) error {
				if err != nil || info == nil {
					return err
				}
				if !info.IsDir() {
					if strings.HasSuffix(path, ".yaml") || strings.HasSuffix(path, ".yml") {
						exp, _ := loadExpByPath(path)
						if exp != nil {
							AllExps = append(AllExps, exp)
						}
					}
				}
				return nil
			})
		if err != nil {
			fmt.Printf("[-] init exp error: %v", err)
		}
	}
}

func checkInfoExp(infostr string) string {
	for _, exp := range rules.ExpDatas {
		if strings.Contains(infostr, exp.Name) {
			return exp.Alias
		}
	}
	return ""
}
func executeExp(ExpInfo config.Expinfo) {
	req, err := http.NewRequest("GET", ExpInfo.Target, nil)
	if err != nil {
		errlog := fmt.Sprintf("[-] webexpinit %v %v", ExpInfo.Target, err)
		common.LogError(errlog)
		return
	}
	req.Header.Set("User-agent", config.UserAgent)
	req.Header.Set("Accept", config.Accept)
	req.Header.Set("Accept-Language", "zh-CN,zh;q=0.9")
	if config.Cookie != "" {
		req.Header.Set("Cookie", config.Cookie)
	}
	exps := filterExp(ExpInfo.ExpName)
	explib.CheckMultiExp(req, exps, config.ExpNum)
}

func loadExp(fileName string, Exps embed.FS) (*poclib.Poc, error) {
	p := &poclib.Poc{}
	var path string
	switch config.ExpType {
	case "base":
		path = "exps/base/" + fileName
	case "software":
		path = "exps/software/" + fileName
	case "iot":
		path = "exps/iot/" + fileName
	case "all":
		path = "exps/all/" + fileName
	default:
		return nil, fmt.Errorf("invalid ExpType: %s", config.ExpType)
	}
	yamlFile, err := Exps.ReadFile(path)
	if err != nil {
		fmt.Printf("[-] load exp %s error1: %v\n", fileName, err)
		return nil, err
	}
	err = yaml.Unmarshal(yamlFile, p)
	if err != nil {
		fmt.Printf("[-] load exp %s error2: %v\n", fileName, err)
		return nil, err
	}
	return p, err
}

// 自定义exp路径
func loadExpByPath(fileName string) (*poclib.Poc, error) {
	p := &poclib.Poc{}
	data, err := os.ReadFile(fileName)
	if err != nil {
		fmt.Printf("[-] load exp %s error3: %v\n", fileName, err)
		return nil, err
	}
	err = yaml.Unmarshal(data, p)
	if err != nil {
		fmt.Printf("[-] load exp %s error4: %v\n", fileName, err)
		return nil, err
	}
	return p, err
}

func filterExp(expName string) (Exps []*poclib.Poc) {
	if expName == "" {
		return AllExps
	}
	for _, exp := range AllExps {
		if strings.Contains(exp.Name, expName) {
			Exps = append(Exps, exp)
		}
	}
	return
}
